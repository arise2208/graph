import React, { useRef, useState, useEffect } from "react";

export default function GraphCanvas() {
  const canvasRef = useRef(null);
  const [nodes, setNodes] = useState([]);
  const [edges, setEdges] = useState([]);
  const [input, setInput] = useState(`0\n1\n2\n3\n4\n0 1\n1 2\n2 3\n3 0\n1 4`);
  const [isDragging, setIsDragging] = useState(false);
  const [dragNodeId, setDragNodeId] = useState(null);
  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
  const [editingNode, setEditingNode] = useState(null);
  const [labelInput, setLabelInput] = useState("");
  
  // Algorithm visualization state
  const [isAnimating, setIsAnimating] = useState(false);
  const [currentAlgorithm, setCurrentAlgorithm] = useState("");
  const [animationStep, setAnimationStep] = useState(0);
  const [algorithmState, setAlgorithmState] = useState({});
  const [selectedNodes, setSelectedNodes] = useState([]);
  const [isDirected, setIsDirected] = useState(false);
  const [speed, setSpeed] = useState(500);
  
  // High-DPI support
  const width = 800, height = 500;
  const dpr = window.devicePixelRatio || 1;

  function parseInput() {
    const lines = input.split("\n").map(l => l.trim()).filter(Boolean);
    const nodeIds = [];
    const edgeList = [];
    
    for (let line of lines) {
      if (/^\d+$/.test(line)) nodeIds.push(Number(line));
      else if (/^\d+\s+\d+(\s+\d+)?$/.test(line)) {
        const parts = line.split(/\s+/).map(Number);
        const [a, b, weight = 1] = parts;
        edgeList.push({ from: a, to: b, weight });
      }
    }
    
    const radius = 200, centerX = width / 2, centerY = height / 2;
    setNodes(nodeIds.map((id, i) => {
      const angle = (2 * Math.PI * i) / nodeIds.length;
      return {
        id,
        x: centerX + radius * Math.cos(angle),
        y: centerY + radius * Math.sin(angle),
        label: "",
        color: "#3b82f6",
        visited: false,
        distance: Infinity,
        parent: null
      };
    }));
    setEdges(edgeList.map(e => ({ ...e, highlighted: false, color: "#aaa" })));
    resetAlgorithmState();
  }

  function resetAlgorithmState() {
    setIsAnimating(false);
    setCurrentAlgorithm("");
    setAnimationStep(0);
    setAlgorithmState({});
    setSelectedNodes([]);
    setNodes(prev => prev.map(n => ({ 
      ...n, 
      color: "#3b82f6", 
      visited: false, 
      distance: Infinity, 
      parent: null 
    })));
    setEdges(prev => prev.map(e => ({ ...e, highlighted: false, color: "#aaa" })));
  }

  // Get mouse position relative to canvas
  function getMousePos(e) {
    const canvas = canvasRef.current;
    const rect = canvas.getBoundingClientRect();
    return {
      x: e.clientX - rect.left,
      y: e.clientY - rect.top
    };
  }

  // Check if point is inside a node
  function getNodeAtPoint(x, y) {
    return nodes.find(node => {
      const dx = x - node.x;
      const dy = y - node.y;
      return Math.sqrt(dx * dx + dy * dy) <= 26;
    });
  }

  // Mouse event handlers
  function handleMouseDown(e) {
    if (isAnimating) return;
    const pos = getMousePos(e);
    const node = getNodeAtPoint(pos.x, pos.y);
    
    if (node) {
      // For algorithm selection
      if (currentAlgorithm && !isAnimating) {
        if (["dijkstra", "bfs", "dfs"].includes(currentAlgorithm)) {
          setSelectedNodes([node.id]);
          return;
        }
      }
      
      setIsDragging(true);
      setDragNodeId(node.id);
      setDragOffset({
        x: pos.x - node.x,
        y: pos.y - node.y
      });
    }
  }

  function handleMouseMove(e) {
    if (!isDragging || dragNodeId === null) return;
    
    const pos = getMousePos(e);
    setNodes(prevNodes => 
      prevNodes.map(node => 
        node.id === dragNodeId 
          ? { ...node, x: pos.x - dragOffset.x, y: pos.y - dragOffset.y }
          : node
      )
    );
  }

  function handleMouseUp() {
    setIsDragging(false);
    setDragNodeId(null);
    setDragOffset({ x: 0, y: 0 });
  }

  function handleDoubleClick(e) {
    if (isAnimating) return;
    const pos = getMousePos(e);
    const node = getNodeAtPoint(pos.x, pos.y);
    
    if (node) {
      setEditingNode(node.id);
      setLabelInput(node.label);
    }
  }

  function saveLabel() {
    if (editingNode !== null) {
      setNodes(prevNodes =>
        prevNodes.map(node =>
          node.id === editingNode
            ? { ...node, label: labelInput }
            : node
        )
      );
      setEditingNode(null);
      setLabelInput("");
    }
  }

  function cancelEdit() {
    setEditingNode(null);
    setLabelInput("");
  }

  // Algorithm implementations
  async function runDijkstra(startNodeId) {
    setIsAnimating(true);
    const distances = {};
    const previous = {};
    const visited = new Set();
    const unvisited = new Set(nodes.map(n => n.id));
    
    // Initialize distances
    nodes.forEach(node => {
      distances[node.id] = node.id === startNodeId ? 0 : Infinity;
      previous[node.id] = null;
    });
    
    setNodes(prev => prev.map(n => ({ 
      ...n, 
      distance: distances[n.id],
      color: n.id === startNodeId ? "#22c55e" : "#3b82f6"
    })));
    
    await sleep(speed);
    
    while (unvisited.size > 0) {
      // Find unvisited node with minimum distance
      let current = null;
      let minDist = Infinity;
      for (let nodeId of unvisited) {
        if (distances[nodeId] < minDist) {
          minDist = distances[nodeId];
          current = nodeId;
        }
      }
      
      if (current === null || distances[current] === Infinity) break;
      
      // Mark current as visited
      visited.add(current);
      unvisited.delete(current);
      
      setNodeColor(current, "#ef4444");
      await sleep(speed);
      
      // Check neighbors
      const neighbors = edges.filter(e => 
        (e.from === current || (!isDirected && e.to === current)) && 
        !visited.has(e.from === current ? e.to : e.from)
      );
      
      for (let edge of neighbors) {
        const neighbor = edge.from === current ? edge.to : edge.from;
        const newDist = distances[current] + edge.weight;
        
        highlightEdge(edge.from, edge.to, "#fbbf24");
        await sleep(speed / 2);
        
        if (newDist < distances[neighbor]) {
          distances[neighbor] = newDist;
          previous[neighbor] = current;
          
          setNodes(prev => prev.map(n => 
            n.id === neighbor ? { ...n, distance: newDist, parent: current } : n
          ));
        }
        
        highlightEdge(edge.from, edge.to, "#aaa");
      }
      
      setNodeColor(current, "#10b981");
    }
    
    setIsAnimating(false);
  }

  async function runBFS(startNodeId) {
    setIsAnimating(true);
    const visited = new Set();
    const queue = [startNodeId];
    const order = [];
    
    setNodeColor(startNodeId, "#22c55e");
    visited.add(startNodeId);
    
    while (queue.length > 0) {
      const current = queue.shift();
      order.push(current);
      
      setNodeColor(current, "#ef4444");
      await sleep(speed);
      
      const neighbors = edges.filter(e => 
        e.from === current || (!isDirected && e.to === current)
      );
      
      for (let edge of neighbors) {
        const neighbor = edge.from === current ? edge.to : edge.from;
        
        if (!visited.has(neighbor)) {
          visited.add(neighbor);
          queue.push(neighbor);
          
          highlightEdge(edge.from, edge.to, "#fbbf24");
          setNodeColor(neighbor, "#22c55e");
          
          setNodes(prev => prev.map(n => 
            n.id === neighbor ? { ...n, parent: current } : n
          ));
          
          await sleep(speed);
          highlightEdge(edge.from, edge.to, "#aaa");
        }
      }
      
      setNodeColor(current, "#10b981");
    }
    
    setIsAnimating(false);
  }

  async function runDFS(startNodeId) {
    setIsAnimating(true);
    const visited = new Set();
    const stack = [startNodeId];
    
    async function dfsRecursive(nodeId) {
      if (visited.has(nodeId)) return;
      
      visited.add(nodeId);
      setNodeColor(nodeId, "#ef4444");
      await sleep(speed);
      
      const neighbors = edges.filter(e => 
        e.from === nodeId || (!isDirected && e.to === nodeId)
      );
      
      for (let edge of neighbors) {
        const neighbor = edge.from === nodeId ? edge.to : edge.from;
        
        if (!visited.has(neighbor)) {
          highlightEdge(edge.from, edge.to, "#fbbf24");
          await sleep(speed / 2);
          
          setNodes(prev => prev.map(n => 
            n.id === neighbor ? { ...n, parent: nodeId } : n
          ));
          
          await dfsRecursive(neighbor);
          
          highlightEdge(edge.from, edge.to, "#aaa");
        }
      }
      
      setNodeColor(nodeId, "#10b981");
    }
    
    await dfsRecursive(startNodeId);
    setIsAnimating(false);
  }

  async function runKruskal() {
    setIsAnimating(true);
    
    // Sort edges by weight
    const sortedEdges = [...edges].sort((a, b) => a.weight - b.weight);
    const mst = [];
    const parent = {};
    
    // Initialize union-find
    nodes.forEach(node => parent[node.id] = node.id);
    
    function find(x) {
      if (parent[x] !== x) {
        parent[x] = find(parent[x]);
      }
      return parent[x];
    }
    
    function union(x, y) {
      const px = find(x);
      const py = find(y);
      if (px !== py) {
        parent[px] = py;
        return true;
      }
      return false;
    }
    
    for (let edge of sortedEdges) {
      highlightEdge(edge.from, edge.to, "#fbbf24");
      await sleep(speed);
      
      if (union(edge.from, edge.to)) {
        mst.push(edge);
        highlightEdge(edge.from, edge.to, "#22c55e");
      } else {
        highlightEdge(edge.from, edge.to, "#ef4444");
        await sleep(speed / 2);
        highlightEdge(edge.from, edge.to, "#aaa");
      }
      
      await sleep(speed / 2);
    }
    
    setIsAnimating(false);
  }

  async function runGraphColoring() {
    setIsAnimating(true);
    const colors = ["#ef4444", "#22c55e", "#3b82f6", "#f59e0b", "#8b5cf6", "#ec4899"];
    const nodeColors = {};
    
    for (let node of nodes) {
      const usedColors = new Set();
      
      // Find colors used by neighbors
      const neighbors = edges.filter(e => 
        e.from === node.id || (!isDirected && e.to === node.id)
      );
      
      for (let edge of neighbors) {
        const neighbor = edge.from === node.id ? edge.to : edge.from;
        if (nodeColors[neighbor] !== undefined) {
          usedColors.add(nodeColors[neighbor]);
        }
      }
      
      // Find first available color
      let colorIndex = 0;
      while (usedColors.has(colorIndex)) {
        colorIndex++;
      }
      
      nodeColors[node.id] = colorIndex;
      setNodeColor(node.id, colors[colorIndex % colors.length]);
      
      await sleep(speed);
    }
    
    setIsAnimating(false);
  }

  async function detectCycles() {
    setIsAnimating(true);
    const allCycles = [];
    const colors = ["#ef4444", "#f59e0b", "#8b5cf6", "#ec4899", "#06b6d4", "#84cc16"];
    
    // For undirected graphs
    if (!isDirected) {
      const visited = new Set();
      
      async function dfsUndirected(nodeId, parent, path) {
        visited.add(nodeId);
        setNodeColor(nodeId, "#fbbf24");
        await sleep(speed / 2);
        
        const neighbors = edges.filter(e => 
          (e.from === nodeId || e.to === nodeId) && 
          (e.from !== parent && e.to !== parent)
        );
        
        for (let edge of neighbors) {
          const neighbor = edge.from === nodeId ? edge.to : edge.from;
          
          if (path.includes(neighbor)) {
            // Cycle found
            const cycleStart = path.indexOf(neighbor);
            const cycle = [...path.slice(cycleStart), nodeId];
            allCycles.push(cycle);
            
            // Highlight this cycle with a unique color
            const color = colors[allCycles.length - 1] || "#ef4444";
            for (let i = 0; i < cycle.length; i++) {
              const from = cycle[i];
              const to = cycle[(i + 1) % cycle.length];
              highlightEdge(from, to, color);
              setNodeColor(from, color);
            }
            await sleep(speed);
          } else if (!visited.has(neighbor)) {
            await dfsUndirected(neighbor, nodeId, [...path, nodeId]);
          }
        }
      }
      
      for (let node of nodes) {
        if (!visited.has(node.id)) {
          await dfsUndirected(node.id, -1, []);
        }
      }
      
    } else {
      // For directed graphs - detect all strongly connected components with cycles
      const visited = new Set();
      const recursionStack = new Set();
      const globalVisited = new Set();
      
      async function dfsDirected(nodeId, path) {
        if (recursionStack.has(nodeId)) {
          // Back edge found - cycle detected
          const cycleStart = path.indexOf(nodeId);
          const cycle = path.slice(cycleStart);
          allCycles.push([...cycle, nodeId]);
          
          // Highlight this cycle
          const color = colors[allCycles.length - 1] || "#ef4444";
          for (let i = 0; i < cycle.length; i++) {
            const from = cycle[i];
            const to = cycle[(i + 1) % cycle.length];
            highlightEdge(from, to, color);
            setNodeColor(from, color);
          }
          setNodeColor(nodeId, color);
          await sleep(speed);
          return;
        }
        
        if (globalVisited.has(nodeId)) return;
        
        visited.add(nodeId);
        recursionStack.add(nodeId);
        globalVisited.add(nodeId);
        
        if (!allCycles.some(cycle => cycle.includes(nodeId))) {
          setNodeColor(nodeId, "#fbbf24");
          await sleep(speed / 3);
        }
        
        const neighbors = edges.filter(e => e.from === nodeId);
        
        for (let edge of neighbors) {
          await dfsDirected(edge.to, [...path, nodeId]);
        }
        
        recursionStack.delete(nodeId);
        
        if (!allCycles.some(cycle => cycle.includes(nodeId))) {
          setNodeColor(nodeId, "#10b981");
        }
      }
      
      for (let node of nodes) {
        if (!globalVisited.has(node.id)) {
          visited.clear();
          recursionStack.clear();
          await dfsDirected(node.id, []);
        }
      }
    }
    
    if (allCycles.length === 0) {
      // Flash green to indicate no cycles
      nodes.forEach(node => setNodeColor(node.id, "#22c55e"));
      await sleep(1000);
      nodes.forEach(node => setNodeColor(node.id, "#3b82f6"));
    } else {
      // Show cycle count
      setAlgorithmState({ cycleCount: allCycles.length, cycles: allCycles });
    }
    
    setIsAnimating(false);
  }

  async function runTopologicalSort() {
    setIsAnimating(true);
    const inDegree = {};
    const result = [];
    
    // Calculate in-degrees
    nodes.forEach(node => inDegree[node.id] = 0);
    edges.forEach(edge => inDegree[edge.to]++);
    
    const queue = nodes.filter(node => inDegree[node.id] === 0).map(n => n.id);
    
    while (queue.length > 0) {
      const current = queue.shift();
      result.push(current);
      
      setNodeColor(current, "#22c55e");
      await sleep(speed);
      
      const outgoingEdges = edges.filter(e => e.from === current);
      
      for (let edge of outgoingEdges) {
        highlightEdge(edge.from, edge.to, "#fbbf24");
        inDegree[edge.to]--;
        
        if (inDegree[edge.to] === 0) {
          queue.push(edge.to);
        }
        
        await sleep(speed / 2);
        highlightEdge(edge.from, edge.to, "#aaa");
      }
      
      setNodeColor(current, "#10b981");
    }
    
    if (result.length !== nodes.length) {
      // Cycle detected
      nodes.forEach(node => {
        if (!result.includes(node.id)) {
          setNodeColor(node.id, "#ef4444");
        }
      });
    }
    
    setIsAnimating(false);
  }

  // Helper functions
  function setNodeColor(nodeId, color) {
    setNodes(prev => prev.map(n => n.id === nodeId ? { ...n, color } : n));
  }

  function highlightEdge(from, to, color) {
    setEdges(prev => prev.map(e => 
      (e.from === from && e.to === to) || (!isDirected && e.from === to && e.to === from)
        ? { ...e, color } : e
    ));
  }

  function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  // Algorithm runners
  async function runAlgorithm(algorithm) {
    if (isAnimating) return;
    
    resetAlgorithmState();
    setCurrentAlgorithm(algorithm);
    
    switch (algorithm) {
      case "dijkstra":
        if (selectedNodes.length > 0) {
          await runDijkstra(selectedNodes[0]);
        }
        break;
      case "bfs":
        if (selectedNodes.length > 0) {
          await runBFS(selectedNodes[0]);
        }
        break;
      case "dfs":
        if (selectedNodes.length > 0) {
          await runDFS(selectedNodes[0]);
        }
        break;
      case "kruskal":
        await runKruskal();
        break;
      case "coloring":
        await runGraphColoring();
        break;
      case "cycles":
        await detectCycles();
        break;
      case "topological":
        await runTopologicalSort();
        break;
    }
  }

  // Drawing function
  function draw() {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext("2d");
    
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, width * dpr, height * dpr);
    ctx.scale(dpr, dpr);
    
    // Edges
    edges.forEach(e => {
      const a = nodes.find(n => n.id === e.from);
      const b = nodes.find(n => n.id === e.to);
      if (a && b) {
        ctx.strokeStyle = e.color;
        ctx.lineWidth = e.highlighted ? 4 : 2;
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.stroke();
        
        // Draw arrow for directed graphs
        if (isDirected) {
          const angle = Math.atan2(b.y - a.y, b.x - a.x);
          const arrowLength = 15;
          const arrowAngle = Math.PI / 6;
          
          const endX = b.x - 26 * Math.cos(angle);
          const endY = b.y - 26 * Math.sin(angle);
          
          ctx.beginPath();
          ctx.moveTo(endX, endY);
          ctx.lineTo(
            endX - arrowLength * Math.cos(angle - arrowAngle),
            endY - arrowLength * Math.sin(angle - arrowAngle)
          );
          ctx.moveTo(endX, endY);
          ctx.lineTo(
            endX - arrowLength * Math.cos(angle + arrowAngle),
            endY - arrowLength * Math.sin(angle + arrowAngle)
          );
          ctx.stroke();
        }
        
        // Draw weight
        if (e.weight !== 1) {
          const midX = (a.x + b.x) / 2;
          const midY = (a.y + b.y) / 2;
          ctx.fillStyle = "#374151";
          ctx.font = "12px Arial";
          ctx.textAlign = "center";
          ctx.fillText(e.weight, midX, midY - 5);
        }
      }
    });
    
    // Nodes
    nodes.forEach(n => {
      ctx.beginPath();
      ctx.arc(n.x, n.y, 26, 0, 2 * Math.PI);
      ctx.fillStyle = n.color + (dragNodeId === n.id ? "CC" : "80");
      ctx.fill();
      ctx.strokeStyle = n.color;
      ctx.lineWidth = 3;
      ctx.stroke();
      
      // Node ID
      ctx.fillStyle = "#ffffff";
      ctx.font = "bold 16px Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(n.id, n.x, n.y);
      
      // Distance for Dijkstra
      if (currentAlgorithm === "dijkstra" && n.distance !== Infinity) {
        ctx.fillStyle = "#374151";
        ctx.font = "12px Arial";
        ctx.fillText(`d:${n.distance}`, n.x, n.y - 35);
      }
      
      // Node label
      if (n.label) {
        ctx.fillStyle = "#374151";
        ctx.font = "13px Arial";
        ctx.fillText(n.label, n.x, n.y + 45);
      }
    });
  }

  useEffect(draw, [nodes, edges, dpr, dragNodeId, currentAlgorithm]);

  return (
    <div className="p-6 flex flex-col items-center bg-gray-50 min-h-screen">
      <div className="mb-4 text-center">
        <h2 className="text-2xl font-bold mb-2">Graph Algorithm Visualizer</h2>
        <p className="text-sm text-gray-600">
          Interactive graph with algorithm animations
        </p>
      </div>
      
      <div className="mb-4 flex gap-4 items-start">
        <div className="flex flex-col">
          <label className="text-sm font-medium mb-1">Graph Input:</label>
          <textarea
            className="border p-2 font-mono text-sm rounded"
            rows={6}
            value={input}
            onChange={e => setInput(e.target.value)}
            style={{ width: 300 }}
            placeholder="Nodes: 0, 1, 2&#10;Edges: 0 1 [weight]"
            disabled={isAnimating}
          />
          <div className="flex gap-2 mt-2">
            <button 
              className="bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded text-sm transition-colors" 
              onClick={parseInput}
              disabled={isAnimating}
            >
              Generate
            </button>
            <button 
              className="bg-gray-500 hover:bg-gray-600 text-white px-3 py-1 rounded text-sm transition-colors" 
              onClick={resetAlgorithmState}
              disabled={isAnimating}
            >
              Reset
            </button>
          </div>
          <div className="mt-2">
            <label className="flex items-center text-sm">
              <input 
                type="checkbox" 
                checked={isDirected} 
                onChange={e => setIsDirected(e.target.checked)}
                className="mr-1"
                disabled={isAnimating}
              />
              Directed Graph
            </label>
          </div>
        </div>
        
        <div className="flex flex-col">
          <label className="text-sm font-medium mb-1">Algorithms:</label>
          <div className="grid grid-cols-2 gap-2 max-w-xs">
            <button 
              className="bg-green-500 hover:bg-green-600 text-white px-3 py-1 rounded text-sm transition-colors"
              onClick={() => runAlgorithm("dijkstra")}
              disabled={isAnimating || nodes.length === 0}
            >
              Dijkstra
            </button>
            <button 
              className="bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded text-sm transition-colors"
              onClick={() => runAlgorithm("bfs")}
              disabled={isAnimating || nodes.length === 0}
            >
              BFS
            </button>
            <button 
              className="bg-purple-500 hover:bg-purple-600 text-white px-3 py-1 rounded text-sm transition-colors"
              onClick={() => runAlgorithm("dfs")}
              disabled={isAnimating || nodes.length === 0}
            >
              DFS
            </button>
            <button 
              className="bg-orange-500 hover:bg-orange-600 text-white px-3 py-1 rounded text-sm transition-colors"
              onClick={() => runAlgorithm("kruskal")}
              disabled={isAnimating || nodes.length === 0}
            >
              MST (Kruskal)
            </button>
            <button 
              className="bg-pink-500 hover:bg-pink-600 text-white px-3 py-1 rounded text-sm transition-colors"
              onClick={() => runAlgorithm("coloring")}
              disabled={isAnimating || nodes.length === 0}
            >
              Graph Coloring
            </button>
            <button 
              className="bg-red-500 hover:bg-red-600 text-white px-3 py-1 rounded text-sm transition-colors"
              onClick={() => runAlgorithm("cycles")}
              disabled={isAnimating || nodes.length === 0}
            >
              Detect Cycles
            </button>
            <button 
              className="bg-indigo-500 hover:bg-indigo-600 text-white px-3 py-1 rounded text-sm transition-colors col-span-2"
              onClick={() => runAlgorithm("topological")}
              disabled={isAnimating || nodes.length === 0}
            >
              Topological Sort
            </button>
          </div>
          
          <div className="mt-3">
            <label className="text-sm font-medium mb-1">Speed:</label>
            <input
              type="range"
              min="100"
              max="2000"
              value={speed}
              onChange={e => setSpeed(Number(e.target.value))}
              className="w-full"
              disabled={isAnimating}
            />
            <div className="text-xs text-gray-500 text-center">
              {speed}ms
            </div>
          </div>
        </div>
      </div>

      {/* Algorithm Results Display */}
      {algorithmState.cycleCount && (
        <div className="mb-4 p-4 bg-red-50 border border-red-300 rounded-lg">
          <h3 className="font-medium text-red-800 mb-2">
            Cycles Detected: {algorithmState.cycleCount}
          </h3>
          <div className="text-sm text-red-700">
            {algorithmState.cycles.map((cycle, index) => (
              <div key={index} className="mb-1">
                <span className="inline-block w-4 h-4 rounded mr-2" 
                      style={{ backgroundColor: ["#ef4444", "#f59e0b", "#8b5cf6", "#ec4899", "#06b6d4", "#84cc16"][index] || "#ef4444" }}>
                </span>
                Cycle {index + 1}: {cycle.join(' → ')}
              </div>
            ))}
          </div>
        </div>
      )}

      {/* Instructions */}
      {currentAlgorithm && ["dijkstra", "bfs", "dfs"].includes(currentAlgorithm) && selectedNodes.length === 0 && (
        <div className="mb-4 p-3 bg-blue-100 border border-blue-300 rounded">
          <p className="text-blue-800 text-sm">
            Click on a node to select it as the starting point for {currentAlgorithm.toUpperCase()}
          </p>
        </div>
      )}

      {/* Label editing modal */}
      {editingNode !== null && (
        <div className="mb-4 p-4 bg-white border rounded-lg shadow-lg">
          <h3 className="font-medium mb-2">Edit Label for Node {editingNode}</h3>
          <div className="flex gap-2">
            <input
              type="text"
              value={labelInput}
              onChange={e => setLabelInput(e.target.value)}
              placeholder="Enter node label"
              className="border px-2 py-1 rounded flex-1"
              autoFocus
              onKeyDown={e => {
                if (e.key === 'Enter') saveLabel();
                if (e.key === 'Escape') cancelEdit();
              }}
            />
            <button 
              onClick={saveLabel}
              className="bg-green-500 hover:bg-green-600 text-white px-3 py-1 rounded text-sm transition-colors"
            >
              Save
            </button>
            <button 
              onClick={cancelEdit}
              className="bg-gray-500 hover:bg-gray-600 text-white px-3 py-1 rounded text-sm transition-colors"
            >
              Cancel
            </button>
          </div>
        </div>
      )}
      
      <canvas
        ref={canvasRef}
        width={width * dpr}
        height={height * dpr}
        style={{
          width: `${width}px`,
          height: `${height}px`,
          border: "1px solid #ddd",
          background: "#fff",
          cursor: isAnimating ? 'wait' : (isDragging ? 'grabbing' : 'grab')
        }}
        onMouseDown={handleMouseDown}
        onMouseMove={handleMouseMove}
        onMouseUp={handleMouseUp}
        onMouseLeave={handleMouseUp}
        onDoubleClick={handleDoubleClick}
      />
      
      <div className="mt-4 text-xs text-gray-500 max-w-2xl">
        <div className="grid grid-cols-2 gap-4">
          <div>
            <p><strong>Graph Input:</strong></p>
            <p>• Nodes: Single numbers (0, 1, 2)</p>
            <p>• Edges: Pairs with optional weight (0 1 5)</p>
            <p>• Double-click nodes to add labels</p>
          </div>
          <div>
            <p><strong>Algorithms:</strong></p>
            <p>• Click node first for Dijkstra/BFS/DFS</p>
            <p>• MST finds minimum spanning tree</p>
            <p>• Coloring uses greedy algorithm</p>
          </div>
        </div>
      </div>
    </div>
  );
}